<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>AirDraw - Dibuja en el aire (MediaPipe Hands)</title>
  <meta name="description" content="AirDraw: dibuja en el aire con la mano. Sube a GitHub Pages y abre en tu Android."/>
  <style>
    :root{
      --bg:#0f1724;
      --card:#111827;
      --muted:#9aa6bd;
      --accent:#ff0055;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:var(--bg);color:#e6eef8}
    .app{max-width:920px;margin:10px auto;padding:12px;}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between}
    h1{font-size:20px;margin:0}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    label{font-size:13px;color:var(--muted)}
    input[type="range"]{width:140px}
    button{background:#1f2937;color:#fff;border:0;padding:8px 10px;border-radius:8px;cursor:pointer}
    button:active{transform:translateY(1px)}
    .stage{margin-top:12px;background:var(--card);border-radius:14px;padding:12px;display:flex;flex-direction:column;align-items:center}
    .video-wrap{position:relative;width:100%;max-width:820px;border-radius:12px;overflow:hidden}
    video, canvas{display:block;width:100%;height:auto}
    video{transform:scaleX(-1);-webkit-transform:scaleX(-1)} /* espejo para webcam */
    canvas{position:absolute;left:0;top:0;pointer-events:none;transform:scaleX(-1)}
    footer{margin-top:8px;color:var(--muted);font-size:13px;text-align:center}
    .status{font-size:13px;color:var(--muted);margin-left:8px}
    @media (max-width:520px){
      input[type="range"]{width:110px}
      header{flex-direction:column;align-items:flex-start;gap:8px}
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>AirDraw</h1>
      <div class="controls">
        <label>Color: <input id="color" type="color" value="#ff0055"></label>
        <label>Grosor: <input id="size" type="range" min="1" max="60" value="6"></label>
        <button id="clear">Borrar</button>
        <button id="save">Guardar</button>
        <span id="status" class="status">Cargando modelo...</span>
      </div>
    </header>

    <div class="stage">
      <div class="video-wrap" id="videoWrap">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="draw"></canvas>
      </div>
      <footer>
        <small>Detecta el *pinch* (índice + pulgar) y dibuja en el aire. Si no funciona, prueba bajar la resolución en tu teléfono o cerrar otras pestañas.</small>
      </footer>
    </div>
  </div>

  <!-- MediaPipe Hands & Camera utils (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    // ---- Config ----
    const video = document.getElementById('video');
    const canvas = document.getElementById('draw');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const colorInput = document.getElementById('color');
    const sizeInput = document.getElementById('size');
    const clearBtn = document.getElementById('clear');
    const saveBtn = document.getElementById('save');

    // Ajustes para rendimiento móvil
    const VIDEO_WIDTH = 640;   // puedes bajar a 480 o 360 si tu celular va lento
    const VIDEO_HEIGHT = 480;

    // Estado de dibujo
    let drawing = false;
    let lastPos = null;
    let smoothedPos = null;
    const SMOOTHING = 0.6; // 0 = sin suavizado, 0.9 = muy suave

    // Inicializa canvas tamaño según video real (y retina)
    function resizeCanvasToVideo() {
      const rect = video.getBoundingClientRect();
      // canvas size in pixels must match video resolution for accurate coords
      canvas.width = video.videoWidth || VIDEO_WIDTH;
      canvas.height = video.videoHeight || VIDEO_HEIGHT;
      // set display size (CSS) to match video element
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
    }

    // Detección de pinch: índice=8, pulgar=4 (MediaPipe landmarks)
    function isPinching(landmarks) {
      if (!landmarks || landmarks.length < 9) return false;
      const idx = landmarks[8];
      const thumb = landmarks[4];
      const dx = idx.x - thumb.x;
      const dy = idx.y - thumb.y;
      const distNorm = Math.sqrt(dx*dx + dy*dy); // en coordenadas normalizadas (0..1)
      // Umbral: 0.06 (ajustable). Multiplica por ancho si quieres px-based threshold.
      return distNorm < 0.06;
    }

    // Convierte landmark normalizado a coordenadas del canvas (sin espejo)
    function landmarkToCanvas(landmark) {
      // landmarks tienen x,y en rango [0,1] con origen en esquina superior izquierda del video.
      return {
        x: landmark.x * canvas.width,
        y: landmark.y * canvas.height
      };
    }

    // Lerp para suavizar
    function lerp(a,b,t){ return a + (b-a)*t; }

    // Dibuja línea suave entre puntos (con suave continuidad)
    function drawLine(from, to, color, size) {
      ctx.lineJoin = ctx.lineCap = 'round';
      ctx.strokeStyle = color;
      ctx.lineWidth = size;
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.stroke();
    }

    // Clear
    clearBtn.addEventListener('click', () => {
      ctx.clearRect(0,0,canvas.width,canvas.height);
    });

    // Save PNG
    saveBtn.addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'airdraw.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    // ---- MediaPipe Hands setup ----
    const hands = new Hands({
      locateFile: (file) => {
        // pide los archivos del CDN de MediaPipe
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
      }
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,           // 0 (rápido) o 1 (mejor). Baja a 0 si va lento en Android.
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.6
    });

    hands.onResults(onResults);

    // Cámara (MediaPipe Camera Utils)
    let camera = null;
    function startCamera() {
      // Preferir la cámara frontal (user) para selfie; si quieres la trasera usa 'environment'
      camera = new Camera(video, {
        onFrame: async () => {
          // envía cada frame al pipeline de Hands
          await hands.send({image: video});
        },
        width: VIDEO_WIDTH,
        height: VIDEO_HEIGHT
      });
      camera.start().catch(err => {
        console.error('No se pudo iniciar la cámara:', err);
        statusEl.textContent = 'Error cámara: ' + (err.message || err);
      });
    }

    // Callback cuando MediaPipe genera resultados
    function onResults(results) {
      // Asegurarse de que canvas coincide con resolución de video
      if (!video.videoWidth) return;
      resizeCanvasToVideo();

      // Opcional: limpiar capa de overlay si quisieras (NO lo hacemos para conservar el dibujo)
      // ctx.clearRect(0,0,canvas.width,canvas.height);

      // Si hay landmarks, procesamos el primero
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const lm = results.multiHandLandmarks[0];

        // Detect pinch
        const pinch = isPinching(lm);

        // Coordenada del índice (landmark 8)
        const idx = landmarkToCanvas(lm[8]);

        // Convertir coordenadas a espejo horizontal porque el video está volteado visualmente
        // El canvas está pintado con las mismas dimensiones del video; para que la línea siga la mano tal como la ves,
        // invertimos la x: x_mirrored = width - x
        const idxMirrored = { x: canvas.width - idx.x, y: idx.y };

        // Inicializar suavizado
        if (!smoothedPos) smoothedPos = { x: idxMirrored.x, y: idxMirrored.y };

        // Smooth lerp
        smoothedPos.x = lerp(smoothedPos.x, idxMirrored.x, 1 - SMOOTHING);
        smoothedPos.y = lerp(smoothedPos.y, idxMirrored.y, 1 - SMOOTHING);

        if (pinch) {
          statusEl.textContent = 'Dibujando';
          const size = parseInt(sizeInput.value,10);
          const color = colorInput.value;

          if (!drawing) {
            drawing = true;
            lastPos = { x: smoothedPos.x, y: smoothedPos.y };
            // dibujar punto inicial
            drawLine(lastPos, smoothedPos, color, size);
            lastPos = { x: smoothedPos.x, y: smoothedPos.y };
          } else {
            // dibuja línea desde lastPos a smoothedPos
            drawLine(lastPos, smoothedPos, color, size);
            lastPos = { x: smoothedPos.x, y: smoothedPos.y };
          }
        } else {
          statusEl.textContent = 'Mano detectada — No dibujando';
          drawing = false;
          lastPos = null;
        }

      } else {
        statusEl.textContent = 'No hay mano visible';
        drawing = false;
        lastPos = null;
      }
    }

    // ---- Inicialización ----
    async function init() {
      try {
        statusEl.textContent = 'Inicializando cámara...';
        // pedir permisos e iniciar cámara
        await navigator.mediaDevices.getUserMedia({ video: true });
        startCamera();
        statusEl.textContent = 'Cargando modelo...';
        // Nada más que esperar: MediaPipe carga internamente desde CDN.
        // Cuando haya frames procesados, onResults empezará a mostrar 'Modelo listo' o estado.
        // Ponemos un timeout de respaldo por si tarda mucho
        setTimeout(() => {
          if (statusEl.textContent === 'Cargando modelo...') {
            statusEl.textContent = 'Modelo cargado — Pon la mano frente a la cámara';
          }
        }, 1200);
      } catch (err) {
        console.error(err);
        statusEl.textContent = 'Permiso denegado o cámara no disponible';
        alert('No se pudo acceder a la cámara. Asegúrate de permitir el permiso y de abrir esto desde HTTPS (GitHub Pages).');
      }
    }

    // Detectar touch para fallback: si prefieres tocar la pantalla para dibujar (útil si la IA falla)
    // Nota: este modo NO usa detección en el aire; solo dibuja con el dedo sobre el canvas.
    (function enableTouchFallback(){
      let touching = false;
      function getTouchPos(e){
        const rect = canvas.getBoundingClientRect();
        const t = e.touches ? e.touches[0] : e;
        // Conversión a coordenadas de canvas (considerando espejo)
        const x = (t.clientX - rect.left) * (canvas.width / rect.width);
        const y = (t.clientY - rect.top) * (canvas.height / rect.height);
        // convertir a espejo para que coincida con video visual
        return { x: canvas.width - x, y: y };
      }
      // start
      canvas.addEventListener('touchstart', (e)=>{
        e.preventDefault();
        touching = true;
        const p = getTouchPos(e);
        lastPos = p;
      }, {passive:false});
      canvas.addEventListener('touchmove', (e)=>{
        if(!touching) return;
        e.preventDefault();
        const p = getTouchPos(e);
        const size = parseInt(sizeInput.value,10);
        const color = colorInput.value;
        drawLine(lastPos, p, color, size);
        lastPos = p;
      }, {passive:false});
      canvas.addEventListener('touchend', (e)=>{
        touching = false;
        lastPos = null;
      });
      // mouse fallback (desktop)
      canvas.addEventListener('mousedown', (e)=>{
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        lastPos = { x: canvas.width - x, y: y };
        touching = true;
      });
      window.addEventListener('mousemove', (e)=>{
        if(!touching) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        const p = { x: canvas.width - x, y: y };
        const size = parseInt(sizeInput.value,10);
        const color = colorInput.value;
        drawLine(lastPos, p, color, size);
        lastPos = p;
      });
      window.addEventListener('mouseup', ()=>{ touching=false; lastPos=null; });
    })();

    // Run
    init();
  </script>
</body>
</html>
